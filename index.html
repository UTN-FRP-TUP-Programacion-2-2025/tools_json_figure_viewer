<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visor JSON 3D - Cilindro</title>
    <!-- Bootstrap 4.3.1 CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        body {
            background-color: #f8f9fa;
        }
        
        .json-tree {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 0.5rem;
            padding: 1rem;
            max-height: 600px;
            overflow-y: auto;
        }
        
        .json-node {
            margin: 0.25rem 0;
            padding-left: 1rem;
        }
        
        .json-key {
            color: #0066cc;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }
        
        .json-key:hover {
            background-color: #e3f2fd;
            border-radius: 3px;
        }
        
        .json-value {
            color: #006600;
            margin-left: 0.5rem;
        }
        
        .json-string {
            color: #cc6600;
        }
        
        .json-number {
            color: #0066cc;
        }
        
        .json-children {
            margin-left: 1rem;
            border-left: 2px solid #e0e0e0;
            padding-left: 0.5rem;
        }
        
        .json-children.collapsed {
            display: none;
        }
        
        .expand-icon {
            margin-right: 0.5rem;
            transition: transform 0.2s;
        }
        
        .expand-icon.collapsed {
            transform: rotate(-90deg);
        }
        
        #canvas-container {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 0.5rem;
            position: relative;
            height: 500px;
        }
        
        #canvas-3d {
            border-radius: 0.5rem;
        }
        
        .controls-panel {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
        }
        
        .info-panel {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
        }
        
        textarea {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        .btn-parse {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            color: white;
        }
        
        .btn-parse:hover {
            background: linear-gradient(45deg, #5a6fd8, #6a4190);
            color: white;
        }
    </style>
</head>
<body>
    <div class="container-fluid py-4">
        <div class="row">
            <div class="col-12">
                <h1 class="text-center mb-4">
                    <i class="fas fa-cube text-primary"></i>
                    Visor JSON 3D - Cilindro Interactivo
                </h1>
            </div>
        </div>
        
        <div class="row">
            <!-- Panel de entrada JSON -->
            <div class="col-lg-6">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="fas fa-code"></i> Entrada JSON</h5>
                    </div>
                    <div class="card-body">
                        <textarea id="jsonInput" class="form-control mb-3" rows="15" placeholder="Pega aquí tu JSON con figuras 3D...">
[ 
  {
  "Tipo": "Cilindro", 
  "Tapas": 
  [
    {  
  "Tipo":"Circulo", 
  "Radio": 3.00, 
  "Area": 28.27
}, 
    {  
  "Tipo":"Circulo", 
  "Radio": 3.00, 
  "Area": 28.27
}
  ],
  "Lado": 
{ 
  "Tipo": "RectanguloDesarrollado", 
  "Lago": 3.00, 
  "Ancho": 18.85, 
  "Area": 56.55
},
  "Area": 113.10,
  "Volumen": 84.82
},
  {  
  "Tipo": "Cubo", 
  "Caras": 
  [
    { 
  "Tipo":"Cuadrado", 
  "Lago": 3.00, 
  "Ancho": 3.00, 
  "Area": 9.00
}, 
{ 
  "Tipo":"Cuadrado", 
  "Lago": 3.00, 
  "Ancho": 3.00, 
  "Area": 9.00
}, 
{ 
  "Tipo":"Cuadrado", 
  "Lago": 3.00, 
  "Ancho": 3.00, 
  "Area": 9.00
}, 
{ 
  "Tipo":"Cuadrado", 
  "Lago": 3.00, 
  "Ancho": 3.00, 
  "Area": 9.00
}, 
{ 
  "Tipo":"Cuadrado", 
  "Lago": 3.00, 
  "Ancho": 3.00, 
  "Area": 9.00
}, 
{ 
  "Tipo":"Cuadrado", 
  "Lago": 3.00, 
  "Ancho": 3.00, 
  "Area": 9.00
}
  ],  
  "Area": 36.00,
  "Volumen": 27.00
},
  {  
  "Tipo": "Ortoedro", 
  "Tapas": 
  [
    
{ 
  "Tipo": "Rectangulo", 
  "Largo": 7.00, 
  "Ancho": 7.00, 
  "Area": 49.00
}, 
    
{ 
  "Tipo": "Rectangulo", 
  "Largo": 7.00, 
  "Ancho": 7.00, 
  "Area": 49.00
}
  ],
  "Laterales": 
    [
      
{ 
  "Tipo": "Rectangulo", 
  "Largo": 21.00, 
  "Ancho": 7.00, 
  "Area": 147.00
}, 
{ 
  "Tipo": "Rectangulo", 
  "Largo": 21.00, 
  "Ancho": 7.00, 
  "Area": 147.00
}, 
{ 
  "Tipo": "Rectangulo", 
  "Largo": 21.00, 
  "Ancho": 7.00, 
  "Area": 147.00
}, 
{ 
  "Tipo": "Rectangulo", 
  "Largo": 21.00, 
  "Ancho": 7.00, 
  "Area": 147.00
}
    ],
  "Area": 686.00,
  "Volumen": 343.00
}
]</textarea>
                        <button id="parseBtn" class="btn btn-parse btn-lg btn-block">
                            <i class="fas fa-play"></i> Procesar JSON
                        </button>
                    </div>
                </div>
                
                <!-- Panel de árbol JSON -->
                <div class="card mt-3">
                    <div class="card-header">
                        <h5><i class="fas fa-sitemap"></i> Estructura Jerárquica</h5>
                    </div>
                    <div class="card-body">
                        <div id="jsonTree" class="json-tree">
                            <em class="text-muted">Procesa un JSON para ver la estructura aquí...</em>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Panel de visualización 3D -->
            <div class="col-lg-6">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="fas fa-cube"></i> Visualización 3D</h5>
                    </div>
                    <div class="card-body">
                        <div id="canvas-container">
                            <canvas id="canvas-3d"></canvas>
                        </div>
                        
                        <div class="controls-panel">
                            <h6><i class="fas fa-cogs"></i> Controles de Vista</h6>
                            <div class="row">
                                <div class="col-md-4">
                                    <button id="resetView" class="btn btn-secondary btn-sm btn-block">
                                        <i class="fas fa-refresh"></i> Restablecer Vista
                                    </button>
                                </div>
                                <div class="col-md-4">
                                    <button id="toggleWireframe" class="btn btn-info btn-sm btn-block">
                                        <i class="fas fa-project-diagram"></i> Wireframe
                                    </button>
                                </div>
                                <div class="col-md-4">
                                    <button id="centerObjects" class="btn btn-success btn-sm btn-block">
                                        <i class="fas fa-crosshairs"></i> Centrar
                                    </button>
                                </div>
                            </div>
                            <div class="mt-2">
                                <small class="text-muted">
                                    <i class="fas fa-mouse"></i> Arrastra para rotar • 
                                    <i class="fas fa-mouse-pointer"></i> Rueda para zoom
                                </small>
                            </div>
                        </div>
                        
                        <div class="info-panel">
                            <h6><i class="fas fa-info-circle"></i> Información del Objeto</h6>
                            <div id="objectInfo">
                                <em class="text-muted">Procesa un JSON para ver información aquí...</em>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Bootstrap 4.3.1 JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>

    <script>
        // Variables globales para Three.js
        let scene, camera, renderer, objects = [];
        let isMouseDown = false, mouseX = 0, mouseY = 0;
        let rotationX = 0, rotationY = 0;
        let showWireframe = false;
        
        // Colores para diferentes tipos de objetos
        const objectColors = {
            'Cilindro': 0x3498db,
            'Cubo': 0xe74c3c,
            'Ortoedro': 0x2ecc71,
            'Rectangulo': 0xf39c12,
            'Cuadrado': 0x9b59b6,
            'Circulo': 0x1abc9c
        };
        
        // Inicializar aplicación
        document.addEventListener('DOMContentLoaded', function() {
            initThreeJS();
            setupEventListeners();
            // Procesar JSON inicial
            document.getElementById('parseBtn').click();
        });
        
        function setupEventListeners() {
            document.getElementById('parseBtn').addEventListener('click', processJSON);
            document.getElementById('resetView').addEventListener('click', resetView);
            document.getElementById('toggleWireframe').addEventListener('click', toggleWireframe);
            document.getElementById('centerObjects').addEventListener('click', centerObjects);
            
            // Controles de mouse para rotación
            const canvas = document.getElementById('canvas-3d');
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel);
        }
        
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            const canvas = document.getElementById('canvas-3d');
            
            // Configurar escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2c3e50);
            
            // Configurar cámara
            camera = new THREE.PerspectiveCamera(75, container.offsetWidth / container.offsetHeight, 0.1, 1000);
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);
            
            // Configurar renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.offsetWidth, container.offsetHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Iluminación
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0x4fc3f7, 0.5, 100);
            pointLight.position.set(-10, 0, 0);
            scene.add(pointLight);
            
            // Añadir grilla de referencia
            const gridHelper = new THREE.GridHelper(50, 50, 0x444444, 0x444444);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
            
            // Iniciar render loop
            animate();
        }
        
        function createCylinder(radius, height, position = { x: 0, y: 0, z: 0 }, color = objectColors.Cilindro) {
            const group = new THREE.Group();
            
            const geometry = new THREE.CylinderGeometry(radius, radius, height, 32);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            
            const cylinderMesh = new THREE.Mesh(geometry, material);
            cylinderMesh.castShadow = true;
            cylinderMesh.receiveShadow = true;
            
            if (showWireframe) {
                const wireframe = new THREE.WireframeGeometry(geometry);
                const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ color: 0x000000 }));
                group.add(line);
            }
            
            group.add(cylinderMesh);
            group.position.set(position.x, height/2, position.z);
            
            return group;
        }
        
        function createCube(size, position = { x: 0, y: 0, z: 0 }, color = objectColors.Cubo) {
            const group = new THREE.Group();
            
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            
            const cubeMesh = new THREE.Mesh(geometry, material);
            cubeMesh.castShadow = true;
            cubeMesh.receiveShadow = true;
            
            if (showWireframe) {
                const wireframe = new THREE.WireframeGeometry(geometry);
                const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ color: 0x000000 }));
                group.add(line);
            }
            
            group.add(cubeMesh);
            group.position.set(position.x, size/2, position.z);
            
            return group;
        }
        
        function createOrtoedro(width, height, depth, position = { x: 0, y: 0, z: 0 }, color = objectColors.Ortoedro) {
            const group = new THREE.Group();
            
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshPhongMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                shininess: 100
            });
            
            const ortoedroMesh = new THREE.Mesh(geometry, material);
            ortoedroMesh.castShadow = true;
            ortoedroMesh.receiveShadow = true;
            
            if (showWireframe) {
                const wireframe = new THREE.WireframeGeometry(geometry);
                const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ color: 0x000000 }));
                group.add(line);
            }
            
            group.add(ortoedroMesh);
            group.position.set(position.x, height/2, position.z);
            
            return group;
        }
        
        function createPlaneShape(type, width, height, position = { x: 0, y: 0, z: 0 }, color) {
            const group = new THREE.Group();
            
            let geometry;
            if (type === 'Circulo') {
                geometry = new THREE.CircleGeometry(width, 32);
                color = color || objectColors.Circulo;
            } else {
                geometry = new THREE.PlaneGeometry(width, height);
                color = color || objectColors.Rectangulo;
            }
            
            const material = new THREE.MeshPhongMaterial({
                color: color,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            
            const planeMesh = new THREE.Mesh(geometry, material);
            planeMesh.receiveShadow = true;
            
            if (showWireframe) {
                const wireframe = new THREE.WireframeGeometry(geometry);
                const line = new THREE.LineSegments(wireframe, new THREE.LineBasicMaterial({ color: 0x000000 }));
                group.add(line);
            }
            
            group.add(planeMesh);
            group.position.set(position.x, 0.1, position.z);
            group.rotation.x = -Math.PI / 2; // Rotar para que esté horizontal
            
            return group;
        }
        
        function getRandomPosition(existingPositions, objectSize) {
            const maxAttempts = 100;
            let attempts = 0;
            
            while (attempts < maxAttempts) {
                const x = (Math.random() - 0.5) * 30;
                const z = (Math.random() - 0.5) * 30;
                
                let collision = false;
                for (let pos of existingPositions) {
                    const distance = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                    const minDistance = objectSize + pos.size + 2; // Margen de seguridad
                    
                    if (distance < minDistance) {
                        collision = true;
                        break;
                    }
                }
                
                if (!collision) {
                    return { x, z, size: objectSize };
                }
                
                attempts++;
            }
            
            // Si no se puede evitar colisión, usar posición aleatoria
            return {
                x: (Math.random() - 0.5) * 40,
                z: (Math.random() - 0.5) * 40,
                size: objectSize
            };
        }
        
        function processJSON() {
            let jsonText = document.getElementById('jsonInput').value;
            
            try {
                // Limpiar JSON de comas finales comunes
                jsonText = cleanJSON(jsonText);
                
                const jsonData = JSON.parse(jsonText);
                
                // Limpiar objetos existentes
                clearScene();
                
                // Crear árbol jerárquico
                createJSONTree(jsonData);
                
                // Actualizar información del objeto
                updateObjectInfo(jsonData);
                
                // Procesar y crear objetos 3D
                if (Array.isArray(jsonData)) {
                    processObjectArray(jsonData);
                } else {
                    // Objeto único
                    const position = { x: 0, y: 0, z: 0 };
                    const obj = create3DObject(jsonData, position);
                    if (obj) {
                        objects.push(obj);
                        scene.add(obj);
                    }
                }
                
            } catch (error) {
                // Mostrar error más detallado
                const errorMsg = `Error al procesar JSON: ${error.message}\n\nSugerencias:\n- Verifica comas finales\n- Revisa comillas y corchetes\n- Asegúrate que todos los objetos estén bien cerrados`;
                alert(errorMsg);
                console.error('JSON Error Details:', error);
                console.log('Cleaned JSON:', jsonText);
            }
        }
        
        function cleanJSON(jsonStr) {
            // Eliminar comentarios de una línea (// ...)
            jsonStr = jsonStr.replace(/\/\/.*$/gm, '');
            
            // Eliminar comentarios de bloque (/* ... */)
            jsonStr = jsonStr.replace(/\/\*[\s\S]*?\*\//g, '');
            
            // Eliminar comas finales antes de } y ]
            // Esto maneja casos como: "key": value, } o "key": value, ]
            jsonStr = jsonStr.replace(/,(\s*[}\]])/g, '$1');
            
            // Limpiar espacios en blanco excesivos
            jsonStr = jsonStr.replace(/\s+/g, ' ').trim();
            
            return jsonStr;
        }
        
        function clearScene() {
            // Remover todos los objetos existentes
            objects.forEach(obj => scene.remove(obj));
            objects = [];
        }
        
        function processObjectArray(dataArray) {
            const positions = [];
            
            dataArray.forEach((objData, index) => {
                let objectSize = 5; // Tamaño por defecto
                
                // Calcular tamaño aproximado del objeto para evitar superposición
                if (objData.Tipo === 'Cilindro' && objData.Tapas && objData.Tapas[0]) {
                    objectSize = objData.Tapas[0].Radio * 2;
                } else if (objData.Tipo === 'Cubo' && objData.Caras && objData.Caras[0]) {
                    objectSize = objData.Caras[0].Lago;
                } else if (objData.Tipo === 'Ortoedro' && objData.Tapas && objData.Tapas[0]) {
                    objectSize = Math.max(objData.Tapas[0].Largo, objData.Tapas[0].Ancho);
                }
                
                const position = getRandomPosition(positions, objectSize);
                positions.push(position);
                
                const obj = create3DObject(objData, { x: position.x, y: 0, z: position.z });
                if (obj) {
                    objects.push(obj);
                    scene.add(obj);
                }
            });
        }
        
        function create3DObject(data, position) {
            const type = data.Tipo;
            
            switch (type) {
                case 'Cilindro':
                    if (data.Tapas && data.Tapas[0] && data.Lado) {
                        const radius = data.Tapas[0].Radio;
                        const height = data.Lado.Lago;
                        return createCylinder(radius, height, position);
                    }
                    break;
                    
                case 'Cubo':
                    if (data.Caras && data.Caras[0]) {
                        const size = data.Caras[0].Lago;
                        return createCube(size, position);
                    }
                    break;
                    
                case 'Ortoedro':
                    if (data.Tapas && data.Tapas[0] && data.Laterales && data.Laterales[0]) {
                        const width = data.Tapas[0].Largo;
                        const depth = data.Tapas[0].Ancho;
                        const height = data.Laterales[0].Ancho;
                        return createOrtoedro(width, height, depth, position);
                    }
                    break;
                    
                case 'Rectangulo':
                    if (data.Largo && data.Ancho) {
                        return createPlaneShape('Rectangulo', data.Largo, data.Ancho, position);
                    }
                    break;
                    
                case 'Cuadrado':
                    if (data.Lago) {
                        return createPlaneShape('Rectangulo', data.Lago, data.Lago, position, objectColors.Cuadrado);
                    }
                    break;
                    
                case 'Circulo':
                    if (data.Radio) {
                        return createPlaneShape('Circulo', data.Radio, data.Radio, position);
                    }
                    break;
            }
            
            return null;
        }
        
        function createJSONTree(data) {
            const container = document.getElementById('jsonTree');
            container.innerHTML = '';
            
            const rootNode = createJSONNode('JSON', data, 0);
            container.appendChild(rootNode);
        }
        
        function createJSONNode(key, value, level) {
            const nodeDiv = document.createElement('div');
            nodeDiv.className = 'json-node';
            
            if (typeof value === 'object' && value !== null) {
                // Crear nodo expandible
                const keySpan = document.createElement('span');
                keySpan.className = 'json-key';
                
                const icon = document.createElement('i');
                icon.className = 'fas fa-chevron-down expand-icon';
                
                const keyText = document.createElement('span');
                keyText.textContent = key;
                
                const typeInfo = document.createElement('span');
                typeInfo.className = 'json-value';
                typeInfo.textContent = Array.isArray(value) ? ` [${value.length}]` : ' {}';
                
                keySpan.appendChild(icon);
                keySpan.appendChild(keyText);
                keySpan.appendChild(typeInfo);
                
                const childrenDiv = document.createElement('div');
                childrenDiv.className = 'json-children';
                
                // Crear nodos hijos
                if (Array.isArray(value)) {
                    value.forEach((item, index) => {
                        const childNode = createJSONNode(`[${index}]`, item, level + 1);
                        childrenDiv.appendChild(childNode);
                    });
                } else {
                    Object.keys(value).forEach(childKey => {
                        const childNode = createJSONNode(childKey, value[childKey], level + 1);
                        childrenDiv.appendChild(childNode);
                    });
                }
                
                // Event listener para colapsar/expandir
                keySpan.addEventListener('click', function() {
                    const isCollapsed = childrenDiv.classList.contains('collapsed');
                    childrenDiv.classList.toggle('collapsed');
                    icon.classList.toggle('collapsed');
                });
                
                nodeDiv.appendChild(keySpan);
                nodeDiv.appendChild(childrenDiv);
                
            } else {
                // Nodo hoja
                const keySpan = document.createElement('span');
                keySpan.className = 'json-key';
                keySpan.textContent = key + ':';
                
                const valueSpan = document.createElement('span');
                valueSpan.className = 'json-value';
                
                if (typeof value === 'string') {
                    valueSpan.className += ' json-string';
                    valueSpan.textContent = `"${value}"`;
                } else if (typeof value === 'number') {
                    valueSpan.className += ' json-number';
                    valueSpan.textContent = value;
                } else {
                    valueSpan.textContent = String(value);
                }
                
                nodeDiv.appendChild(keySpan);
                nodeDiv.appendChild(valueSpan);
            }
            
            return nodeDiv;
        }
        
        function updateObjectInfo(data) {
            const infoDiv = document.getElementById('objectInfo');
            
            if (Array.isArray(data)) {
                let html = `<h6>Colección de ${data.length} objetos:</h6>`;
                
                data.forEach((obj, index) => {
                    html += `
                        <div class="mb-2 p-2 bg-light rounded">
                            <strong>${obj.Tipo || 'Objeto'} ${index + 1}:</strong><br>
                            <small>
                                Área: ${obj.Area || 'N/A'} • 
                                Volumen: ${obj.Volumen || 'N/A'}
                            </small>
                        </div>
                    `;
                });
                
                infoDiv.innerHTML = html;
            } else {
                let html = `
                    <div class="row">
                        <div class="col-md-6">
                            <strong>Tipo:</strong> ${data.Tipo || 'N/A'}<br>
                            <strong>Área Total:</strong> ${data.Area || 'N/A'}<br>
                            <strong>Volumen:</strong> ${data.Volumen || 'N/A'}
                        </div>
                        <div class="col-md-6">
                `;
                
                if (data.Tapas && data.Tapas.length > 0) {
                    html += `<strong>Tapas:</strong> ${data.Tapas.length}<br>`;
                    html += `<strong>Radio:</strong> ${data.Tapas[0].Radio || 'N/A'}<br>`;
                }
                
                if (data.Caras && data.Caras.length > 0) {
                    html += `<strong>Caras:</strong> ${data.Caras.length}<br>`;
                    html += `<strong>Lado:</strong> ${data.Caras[0].Lago || 'N/A'}<br>`;
                }
                
                if (data.Lado) {
                    html += `<strong>Altura:</strong> ${data.Lado.Lago || 'N/A'}<br>`;
                }
                
                html += '</div></div>';
                infoDiv.innerHTML = html;
            }
        }
        
        function updateCylinder() {
            const radius = parseFloat(document.getElementById('radiusSlider').value);
            const height = parseFloat(document.getElementById('heightSlider').value);
            
            document.getElementById('radiusValue').textContent = radius.toFixed(1);
            document.getElementById('heightValue').textContent = height.toFixed(1);
            
            createCylinder(radius, height);
        }
        
        function resetView() {
            camera.position.set(15, 10, 15);
            camera.lookAt(0, 0, 0);
            rotationX = 0;
            rotationY = 0;
            
            // Resetear rotación de todos los objetos
            objects.forEach(obj => {
                obj.rotation.x = 0;
                obj.rotation.y = 0;
                obj.rotation.z = 0;
            });
        }
        
        // Controles de mouse
        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseMove(event) {
            if (!isMouseDown || objects.length === 0) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            rotationY += deltaX * 0.01;
            rotationX += deltaY * 0.01;
            
            // Aplicar rotación a todos los objetos
            objects.forEach(obj => {
                obj.rotation.x = rotationX;
                obj.rotation.y = rotationY;
            });
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }
        
        function onMouseUp() {
            isMouseDown = false;
        }
        
        function onWheel(event) {
            event.preventDefault();
            const scale = event.deltaY > 0 ? 1.1 : 0.9;
            camera.position.multiplyScalar(scale);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotación automática sutil cuando no hay interacción del mouse
            if (objects.length > 0 && !isMouseDown) {
                objects.forEach(obj => {
                    obj.rotation.y += 0.003;
                });
            }
            
            renderer.render(scene, camera);
        }
        
        // Responsive
        window.addEventListener('resize', function() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.offsetWidth / container.offsetHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.offsetWidth, container.offsetHeight);
        });
    </script>
</body>
</html>